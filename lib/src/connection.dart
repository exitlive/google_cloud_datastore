library connection;

import 'dart:io';
import 'dart:async';
import 'dart:convert' show JSON;
import 'dart:math' as math;

import 'package:logging/logging.dart';
import 'package:http/http.dart' as http;
import 'package:protobuf/protobuf.dart';
import 'package:google_oauth2_client/google_oauth2_console.dart' as oauth2;

import 'proto/schema_v1_pb2.dart';


/**
 * The API scopes required by google cloud datastore access
 */
const List<String> API_SCOPE =
    const ['https://www.googleapis.com/auth/datastore',
           'https://www.googleapis.com/auth/userinfo.email'];

const String GOOGLE_API_URL = 'https://www.googleapis.com';
const String API_VERSION = 'v1beta2';

typedef Future<http.StreamedResponse> _SendRequest(http.Request request);



/**
 * Reads the private key file located at [:path:]
 */
Future _readPrivateKey(String path) {
  if (path == null)
    return new Future.value();
  return new File(path).readAsString();
}

class DatastoreConnection {

  //A random number generator.
  static final _RANDOM = new math.Random();

  /**
   * The logger for records generated by the [DatastoreConnection] instance.
   * Log records are, by default, written to the 'datastore.connection' logger.
   */
  Logger logger = new Logger("datastore.connection");

  /**
   * The dataset to connect to. Same as the project ID
   */
  final String datasetId;

  final http.Client _client;

  /**
   * The hostname of the datastore. defaults to `https://www.googleapis.com`.
   *
   * Until dart oauth supports service account request, this is hardcoded to 'http://localhost:5556'
   * which is a python server on localhost which reads authorises the request
   * and forwards the result onto the datastore.
   */
  final String host;

  /**
   * The duration to wait before logging a timeout exception and failing
   * the request. Defaults to `30` seconds.
   */
  Duration timeoutDuration = new Duration(seconds: 30);

  String get _url => '$host/datastore/$API_VERSION/datasets/$datasetId';


  /**
   * Create a new [DatastoreConnection] to the dataset with [:datasetId:].
   * [:client:] is the http.Client used to send connections to [:host:].
   *
   * Typically, client code should use [:DatastoreConnection.openSync:] rather
   * than calling the constructor directly.
   */
  DatastoreConnection(this.datasetId, http.Client this._client, this.host);

  /**
   * The number of times to retry the transaction when receiving one of the
   * [:retryStatusCodes:].
   */
  int maxRequestRetries = 5;

  /**
   * A list of status codes which will trigger a retry attempt by the connection
   */
  List<int> retryStatusCodes = [409, 403, 500, 503];

  /**
   * Creates a new [DatastoreConnection].
   *
   * [:datasetId:] is the id of the dataset to connect to, usually the same
   * as the google assigned `project ID` associated with the dataset.
   *
   * If connecting to a remote instance of the datastore via a service account, the
   * following two arguments must both be provided, otherwise they should be `null`.
   *
   * [:serviceAccount:] is a service account email used for
   * authenticating with a remote instance of the datastore.
   * [:pathToPrivateKey:] is the filesystem path to the authentication token
   * in the `.pem` format for the service account.
   *
   * If connecting to an instance of the `gcd` tool at the specified `host`, then
   * the [:host:] argument should be set to the location of a running instance of
   * the `gcd` tool.
   */
  static DatastoreConnection openSync(String datasetId,
        { String serviceAccount, String pathToPrivateKey, String host}) {
    var makeAuthRequests = false;
    if (host == null) {
      host = GOOGLE_API_URL;
      makeAuthRequests = true;
    }

    var client;
    if (makeAuthRequests) {
      if (serviceAccount != null) {
        if (pathToPrivateKey != null) {
          throw new StateError('Private key msut be provided for use with service account');
        }
        var privateKey = new File(pathToPrivateKey).readAsStringSync();
        client = new oauth2.OtherPlatformClient(
            datasetId,
            serviceAccount,
            privateKey,
            API_SCOPE.join(" ")
        );
      } else {
        client = new oauth2.ComputeEngineClient(datasetId);
      }
    } else {
      client = new http.Client();
    }
    return new DatastoreConnection(datasetId,client, host);
  }

  @deprecated
  static Future<DatastoreConnection> open(String projectNumber, String datasetId,
        { String serviceAccount, String pathToPrivateKey, String host}) =>
      new Future.sync(() => openSync(
          datasetId,
          serviceAccount: serviceAccount,
          pathToPrivateKey: pathToPrivateKey,
          host: host
      ));

  /**
   * Submits a lookup request to the datastore.
   *
   * Throws an [RPCException] if the server responds with an invalid status
   */
  Future<LookupResponse> lookup(LookupRequest request) =>
      _call("lookup", request, (bytes) => new LookupResponse.fromBuffer(bytes));

  Future<RunQueryResponse> runQuery(RunQueryRequest request) =>
      _call("runQuery", request, (bytes) => new RunQueryResponse.fromBuffer(bytes));

  Future<BeginTransactionResponse> beginTransaction(BeginTransactionRequest request) =>
      _call("beginTransaction", request, (bytes) => new BeginTransactionResponse.fromBuffer(bytes));

  /**
   * Commit the request to the datastore.
   * [CommitRequest]s are not retried automatically by the connection
   */
  Future<CommitResponse> commit(CommitRequest request) =>
      _call("commit", request, (bytes) => new CommitResponse.fromBuffer(bytes), retryRequest: false);

  /**
   * Rollback the request in the datastore
   * [RollbackRequest]s are not retried automatically by the connection
   */
  Future<RollbackResponse> rollback(RollbackRequest request) =>
      _call("rollback", request, (bytes) => new RollbackResponse.fromBuffer(bytes), retryRequest: false);

  Future<AllocateIdsResponse> allocateIds(AllocateIdsRequest request) =>
      _call("allocateIds", request, (bytes) => new AllocateIdsResponse.fromBuffer(bytes));

  /**
   * Send a remote shutdown request to the server.
   * Will only successfully perform a shutdown on a test server, production
   * servers will not respond.
   */
  Future sendRemoteShutdown() {
    logger.severe("SUBMITTING REMOTE SHUTDOWN REQUEST");
    return http.post('$host/_ah/admin/quit');
  }

  Future _call(String method, GeneratedMessage message, GeneratedMessage reconstructResponse(List<int> bytes), {int retryCount: 0, bool retryRequest: true}) {
    var request = new http.Request("POST", Uri.parse("$_url/$method"))
        ..headers['content-type'] = 'application/x-protobuf'
        ..bodyBytes = message.writeToBuffer();
    logger.info("($method) request sent to ${request.url}");

    return _client.send(request)
        .timeout(
            timeoutDuration,
            onTimeout: () {
              logger.severe("Request to $method timed out after $timeoutDuration");
            })
        .then(http.Response.fromStream)
        .then((http.Response response) {
          if (response.statusCode != 200) {
            logger.severe("Request to $method failed with status ${response.statusCode}");
            if (retryRequest &&
                retryCount < maxRequestRetries &&
                retryStatusCodes.contains(response.statusCode)) {
              logger.warning('Retrying request... (Retry count: $retryCount)');
              var retryDuration = new Duration(
                  seconds: math.pow(2, retryCount - 1).ceil(),
                  milliseconds: _RANDOM.nextInt(500)
              );
              return new Future.delayed(
                  retryDuration,
                  () => _call(method, message, reconstructResponse, retryCount: ++retryCount)
              );
            }
            logger.severe(response.body);
            var jsonResponse = JSON.decode(response.body);
            throw new RPCException(response.statusCode, method, jsonResponse['error']['message']);
          }

          logger.info("Server returned valid ($method) response");
          return reconstructResponse(response.bodyBytes);
        });
  }
}

class RPCException implements Exception {
  final int status;
  final String method;
  final String reason;

  RPCException(int this.status, String this.method, this.reason);

  String toString() {
    var msg = "Remote procedure call $method failed with status $status";
    if (reason != null) {
      msg += "\n\tmessage: $reason";
    }
    return msg;
  }
}